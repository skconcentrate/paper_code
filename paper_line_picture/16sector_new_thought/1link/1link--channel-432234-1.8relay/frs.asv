clear all;
clc;
ui_caf_frssum=0;
ui_caf_arssum=0;
ui_cdf_frssum=0;
ui_cdf_arssum=0;
% 循环次数
simulateno=10;
channel_times=10;
%sumsta个随机节点，其中2*linkno个作为S和D，其余sumr个作为R
ui_pt=10;%发送功率
ui_linkno=1;%链路数目
ui_sumsta=10;%STA数目
ui_sumr=ui_sumsta-2*ui_linkno;%可作为R的数目
ui_bandwith=2000000000;%带宽2GHz
NL=-174 + 10*log10(ui_bandwith);%噪声功率，单位dBm
ui_sumsector=16;%扇区数设为16
ui_theta_l=360/ui_sumsector;%扇区角度值
vec_FRS_AF_RESULT=zeros(1,simulateno);
vec_FRS_DF_RESULT=zeros(1,simulateno);
vec_ARS_AF_RESULT=zeros(1,simulateno);
vec_ARS_DF_RESULT=zeros(1,simulateno);

for caltimes=1:simulateno
%source矩阵
vec_source=1:ui_linkno;

%destination矩阵
vec_destination=(ui_linkno+1):(2*ui_linkno);

%STA坐标矩阵
locate_node=zeros(2,ui_sumsta);
locate_node(1,:)=rand(1,ui_sumsta)*10;
locate_node(2,:)=rand(1,ui_sumsta)*10;

%距离矩阵
vec_stadistance=zeros(ui_sumsta);
for i_temp=1:ui_sumsta
    for j_temp=1:ui_sumsta
        if (i_temp==j_temp)
            vec_stadistance(i_temp,j_temp)=0;
        else
            vec_stadistance(i_temp,j_temp)=caldistance(locate_node,i_temp,j_temp);
        end
    end
end
clear i_temp;
clear j_temp;

%Block与S和D的距离
ui_block_d2s=unifrnd(0,1)*(vec_stadistance(1,2)-1)+0.5;
ui_block_d2d=vec_stadistance(1,2)-ui_block_d2s;
if ((ui_block_d2s<0.5) || (ui_block_d2d<0.5))
    continue;
end

%Block阻挡S和D的角度大小
ui_block_s_half_angle=asin(0.5/ui_block_d2s)*180/pi;
if (ui_block_s_half_angle<0)
    ui_block_s_half_angle=ui_block_s_half_angle+180;
end
ui_block_d_half_angle=asin(0.5/ui_block_d2d)*180/pi;
if (ui_block_d_half_angle<0)
    ui_block_d_half_angle=ui_block_d_half_angle+180;
end

%角度矩阵
vec_angle=zeros(ui_sumsta);
for i_temp=1:ui_sumsta
    for j_temp=1:ui_sumsta
        if (i_temp==j_temp)
            vec_angle(i_temp,j_temp)=0;
        else
            vec_angle(i_temp,j_temp)=calangle(locate_node,i_temp,j_temp);
        end
    end
end
clear i_temp;
clear j_temp;

%扇区号矩阵
%vec_sectorid=zeros(ui_sumsta);
vec_sectorid=floor(vec_angle/ui_theta_l)+1;
for i_temp=1:ui_sumsta
    vec_sectorid(i_temp,i_temp)=0;
end
clear i_temp;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                      FRS(fast relay selection)                          %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
for link_temp=1:ui_linkno
    vec_sectorweight=zeros(1,ui_sumsta);
    %先靠D所在S的扇区id筛选出可用R集合（+/-1,2,3,4,5）
    %vec_sectorid(vec_source(i_temp),vec_destination(i_temp))是D所在S的扇区id
    ui_d_sectorid=vec_sectorid(vec_source(link_temp),vec_destination(link_temp));
    vec_left_right_sector=zeros(3,5);
    vec_left_right_sector(1,:)=1:5;
    for i_temp=1:5
        vec_left_right_sector(2,i_temp)=ui_d_sectorid+i_temp-6;
        vec_left_right_sector(3,i_temp)=ui_d_sectorid+i_temp;
        
        if (vec_left_right_sector(2,i_temp)<=0)
            vec_left_right_sector(2,i_temp)=vec_left_right_sector(2,i_temp)+ui_sumsector;
        end
        if (vec_left_right_sector(2,i_temp)>ui_sumsector)
            vec_left_right_sector(2,i_temp)=rem(vec_left_right_sector(2,i_temp),ui_sumsector);
        end
        
        if (vec_left_right_sector(3,i_temp)<=0)
            vec_left_right_sector(3,i_temp)=vec_left_right_sector(3,i_temp)+ui_sumsector;
        end
        if (vec_left_right_sector(3,i_temp)>ui_sumsector)
            vec_left_right_sector(3,i_temp)=rem(vec_left_right_sector(3,i_temp),ui_sumsector);
        end
    end
    
    clear ui_d_sectorid;
    
    %左右1扇区权重0.3，左右2扇区权重0.2，其余扇区权重0
    for stano=(2*ui_linkno+1):ui_sumsta
        if (vec_sectorid(link_temp,stano)==vec_left_right_sector(2,1) || vec_sectorid(link_temp,stano)==vec_left_right_sector(3,1))
            vec_sectorweight(1,stano)=0.2;
        elseif (vec_sectorid(link_temp,stano)==vec_left_right_sector(2,2) || vec_sectorid(link_temp,stano)==vec_left_right_sector(3,2))
            vec_sectorweight(1,stano)=0.15;
        elseif (vec_sectorid(link_temp,stano)==vec_left_right_sector(2,3) || vec_sectorid(link_temp,stano)==vec_left_right_sector(3,3))
            vec_sectorweight(1,stano)=0.1;
        elseif (vec_sectorid(link_temp,stano)==vec_left_right_sector(2,4) || vec_sectorid(link_temp,stano)==vec_left_right_sector(3,4))
            vec_sectorweight(1,stano)=0.03;
        elseif (vec_sectorid(link_temp,stano)==vec_left_right_sector(2,5) || vec_sectorid(link_temp,stano)==vec_left_right_sector(3,5))
            vec_sectorweight(1,stano)=0.02;
        else
            vec_sectorweight(1,stano)=0;
        end
    end
    clear stano;
    
    %取出扇区权重非0的下标,即R的id
    vec_validsectorno=find(vec_sectorweight);
    
    ui_validrno=nnz(vec_validsectorno);%扇区权重非0的R的个数
    if (ui_validrno == 0)
        return;
    end
    
    %ui_rlos为直连链路LOS接收信号能量；ui_rri为S-R-D链路信号接收能量
    %发送功率为10dbm
    %R权重
    vec_rweight=zeros(1,ui_validrno);
    vec_rri=zeros(1,ui_validrno);
    vec_rri_pw=zeros(1,ui_validrno);
    for channel_temp=1:channel_times
        vec_rlos(1,channel_temp)=ui_pt+path_los_simu(vec_stadistance(link_temp,2*link_temp),vec_angle(link_temp,2*link_temp)-vec_sectorid(link_temp,2*link_temp)*ui_theta_l,ui_theta_l);
    end
    vec_rlos_sort=sort(vec_rlos);
    vec_rlos_top90=vec_rlos_sort(1,(channel_times*0.1+1):channel_times);
    ui_rlos=mean(vec_rlos_top90)-20;
    clear channel_temp;
    %ui_rlos=-22.5-20*log10(vec_stadistance(link_temp,2*link_temp)/1000)-20*log10(60000);
    
    for stano=1:ui_validrno
        %S-R链路path_loss
        for channel_temp=1:channel_times
            vec_rri_sr_los(1,channel_temp)=path_los_simu(vec_stadistance(link_temp,vec_validsectorno(stano)),abs(vec_angle(link_temp,vec_validsectorno(stano))-vec_sectorid(link_temp,vec_validsectorno(stano))*ui_theta_l),ui_theta_l);
            if ((vec_angle(link_temp,vec_validsectorno(stano))>vec_angle(link_temp,ui_linkno+link_temp)-ui_block_s_half_angle) && (vec_angle(link_temp,vec_validsectorno(stano))<vec_angle(link_temp,ui_linkno+link_temp)+ui_block_s_half_angle))
                vec_rri_sr_los(1,channel_temp)=vec_rri_sr_los(1,channel_temp)-20;
            end
        end
        vec_rri_sr_los_sort=sort(vec_rri_sr_los);
        vec_rri_sr_los_top90=vec_rri_sr_los_sort(1,(channel_times*0.1+1):channel_times);
        ui_rri_sr_los=mean(vec_rri_sr_los_top90);
        clear channel_temp;
        
        %R-D链路path_loss
        for channel_temp=1:channel_times
            vec_rri_rd_los(1,channel_temp)=path_los_simu(vec_stadistance(link_temp+ui_linkno,vec_validsectorno(stano)),abs(vec_angle(vec_validsectorno(stano),link_temp+ui_linkno)-vec_sectorid(vec_validsectorno(stano),link_temp+ui_linkno)*ui_theta_l),ui_theta_l);
            if ((vec_angle(ui_linkno+link_temp,vec_validsectorno(stano))>vec_angle(ui_linkno+link_temp,link_temp)-ui_block_d_half_angle) && (vec_angle(ui_linkno+link_temp,vec_validsectorno(stano))<vec_angle(ui_linkno+link_temp,link_temp)+ui_block_d_half_angle))
                vec_rri_rd_los(1,channel_temp)=vec_rri_rd_los(1,channel_temp)-20;
            end
        end
        vec_rri_rd_los_sort=sort(vec_rri_rd_los);
        vec_rri_rd_los_top90=vec_rri_rd_los_sort(1,(channel_times*0.1+1):channel_times);
        ui_rri_rd_los=mean(vec_rri_rd_los_top90);
        clear channel_temp;
        
%         ui_rri=ui_pt+ui_rri_sr_los+ui_rri_rd_los;
        vec_rri(1,stano)=ui_pt+ui_rri_sr_los+ui_rri_rd_los;
        
        %%ui_rlos_pw=(10^(ui_rlos/10))/(10^(NL/10));
        %ui_rri_pw=(10^(vec_rri(1,stano)/10))/(10^(NL/10));
        %%vec_rri_pw(1,stano)=(10^(vec_rri(1,stano)/10))/(10^(NL/10));
           
        %ui_rri=-22.5-20*log10((vec_stadistance(link_temp,vec_validsectorno(stano))+vec_stadistance(2*link_temp,vec_validsectorno(stano)))/1000)-20*log10(60000);
        vec_rweight(1,stano)=(1-abs(vec_rri(1,stano)/ui_rlos-1));
        %%vec_rweight(1,stano)=(1-abs(vec_rri_pw(1,stano)/ui_rlos_pw-1));
    end
    
    clear stano;
    
    for stano=1:ui_validrno
        if (vec_rweight(1,stano)<0)
            
        end
    end
%     clear ui_rri;
%    clear ui_rlos;
    
    %vec_sumweight:总权重矩阵：求总权重
    vec_sumweight=zeros(2,ui_validrno);
    for stano=1:ui_validrno
        vec_sumweight(1,stano)=vec_validsectorno(stano);
        vec_sumweight(2,stano)=vec_rweight(1,stano)*vec_sectorweight(1,vec_validsectorno(stano));
    end
    clear stano;
    
    %以vec_sumweight第2行总权重为标准对矩阵按列升序排序，权重最大的排在最后
    [temp,index]=sort(vec_sumweight(2,:));%以2行大小作为排序标准
    for i_temp=1:ui_validrno
        vec_sortweight(:,i_temp)=vec_sumweight(:,index(i_temp));
    end
    clear temp;
    clear i_temp;
    clear index;
    
    %暂时选取最优的R作为唯一的R
    ui_frs_bestrid=vec_sortweight(1,ui_validrno);
    
    
end
clear link_temp;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                      ARS(all relay selection)                          %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
for link_temp=1:ui_linkno
    
    %遍历计算每个R链路的信道容量C
    vec_rsnr4all=zeros(5,ui_sumr);
    for channel_temp=1:channel_times
        vec_rlos(1,channel_temp)=ui_pt+path_los_simu(vec_stadistance(link_temp,2*link_temp),vec_angle(link_temp,2*link_temp)-vec_sectorid(link_temp,2*link_temp)*ui_theta_l,ui_theta_l);
    end
    vec_rlos_sort=sort(vec_rlos);
    vec_rlos_top90=vec_rlos_sort(1,(channel_times*0.1+1):channel_times);
    ui_rlos=mean(vec_rlos_top90)-20;
    clear channel_temp;
    %ui_rlos=-22.5-20*log10(vec_stadistance(link_temp,2*link_temp)/1000)-20*log10(60000);
    
    for stano=1:ui_sumr
        vec_rsnr4all(1,stano)=stano+2*ui_linkno;
        
        %S-R链路SNR
        for channel_temp=1:channel_times
            vec_srdbsnr4all(1,channel_temp)=ui_pt+path_los_simu(vec_stadistance(link_temp,stano+2*ui_linkno),abs(vec_angle(link_temp,stano+2*ui_linkno)-vec_sectorid(link_temp,stano+2*ui_linkno)*ui_theta_l),ui_theta_l);
            if ((vec_angle(link_temp,stano+2*ui_linkno)>vec_angle(link_temp,2*link_temp)-ui_block_s_half_angle) && (vec_angle(link_temp,stano+2*ui_linkno)<vec_angle(link_temp,2*link_temp)+ui_block_s_half_angle))
                vec_srdbsnr4all(1,channel_temp)=vec_srdbsnr4all(1,channel_temp)-20;
            end
        end
        vec_srdbsnr4all_sort=sort(vec_srdbsnr4all);
        vec_srdbsnr4all_top90=vec_srdbsnr4all_sort(1,(channel_times*0.1+1):channel_times);
        ui_srdbsnr4all=mean(vec_srdbsnr4all_top90);
        clear channel_temp;
        vec_rsnr4all(2,stano)=ui_srdbsnr4all;
        
        %R-D链路SNR
        for channel_temp=1:channel_times
            vec_rddbsnr4all(1,channel_temp)=ui_pt+path_los_simu(vec_stadistance(2*link_temp,stano+2*ui_linkno),abs(vec_angle(stano+2*ui_linkno,2*link_temp)-vec_sectorid(stano+2*ui_linkno,2*link_temp)*ui_theta_l),ui_theta_l);
            if ((vec_angle(2*link_temp,stano+2*ui_linkno)>vec_angle(2*link_temp,link_temp)-ui_block_d_half_angle) && (vec_angle(2*link_temp,stano+2*ui_linkno)<vec_angle(2*link_temp,link_temp)+ui_block_d_half_angle))
                vec_rddbsnr4all(1,channel_temp)=vec_rddbsnr4all(1,channel_temp)-20;
            end
        end
        vec_rddbsnr4all_sort=sort(vec_rddbsnr4all);
        vec_rddbsnr4all_top90=vec_rddbsnr4all_sort(1,(channel_times*0.1+1):channel_times);
        ui_rddbsnr4all=mean(vec_rddbsnr4all_top90);
        clear channel_temp;
        vec_rsnr4all(3,stano)=ui_rddbsnr4all;
        
        ui_SNRsd4all=(10^(ui_rlos/10))/(10^(NL/10));
        ui_SNRsr4all=(10^(ui_srdbsnr4all/10))/(10^(NL/10));
        ui_SNRrd4all=(10^(ui_rddbsnr4all/10))/(10^(NL/10));
        ui_caf_ars=0.5*ui_bandwith*log2(1+ui_SNRsd4all+ui_SNRsr4all*ui_SNRrd4all/(ui_SNRsr4all+ui_SNRrd4all+1));
        ui_cdf_ars=0.5*ui_bandwith*min(log2(1+ui_SNRsr4all),log2(1+ui_SNRsd4all+ui_SNRrd4all));
        vec_rsnr4all(4,stano)=ui_caf_ars;
        vec_rsnr4all(5,stano)=ui_cdf_ars;
    end
    clear stano;
    clear ui_rri4all;
 %   clear ui_rlos;

    %以vec_sumweight第4行C_AF为标准对矩阵按列升序排序，C_AF最大的排在最后
    [temp,index]=sort(vec_rsnr4all(4,:));%以4行大小作为排序标准
    for i_temp=1:ui_sumr
        vec_sortrsnr4all_af(:,i_temp)=vec_rsnr4all(:,index(i_temp));
    end
    clear temp;
    clear i_temp;
    clear index;
    
    %以vec_sumweight第5行C_DF为标准对矩阵按列升序排序，C_DF最大的排在最后
    [temp,index]=sort(vec_rsnr4all(5,:));%以5行大小作为排序标准
    for i_temp=1:ui_sumr
        vec_sortrsnr4all_df(:,i_temp)=vec_rsnr4all(:,index(i_temp));
    end
    clear temp;
    clear i_temp;
    clear index;
    
    %暂时选取最优的R作为唯一的R
    ui_ars_bestrid4all_af=vec_sortrsnr4all_af(1,ui_sumr);
    ui_ars_bestrid4all_df=vec_sortrsnr4all_df(1,ui_sumr);
    vec_ARS_AF_RESULT(1,caltimes)=vec_sortrsnr4all_af(4,ui_sumr);
    vec_ARS_DF_RESULT(1,caltimes)=vec_sortrsnr4all_df(5,ui_sumr);
    
    if ((vec_sortrsnr4all_af(4,ui_sumr) < vec_rsnr4all(4,ui_frs_bestrid-2*ui_linkno)) || (vec_sortrsnr4all_df(5,ui_sumr) < vec_rsnr4all(5,ui_frs_bestrid-2*ui_linkno)))
        disp(sprintf('wrong no:af=%d\tdf=%d\tfrs=%d\t%d\n',vec_sortrsnr4all_af(4,ui_sumr),vec_sortrsnr4all_df(5,ui_sumr),vec_rsnr4all(4,ui_frs_bestrid-2*ui_linkno),vec_rsnr4all(5,ui_frs_bestrid-2*ui_linkno)));
    end
    
end
clear link_temp;


%比较两种relay选择的性能：

%比较DF和AF两种relay方式下，FRS与ARS信道容量的差距
%AF%
ui_caf_frssum=ui_caf_frssum+vec_rsnr4all(4,ui_frs_bestrid-2*ui_linkno);
ui_caf_arssum=ui_caf_arssum+vec_sortrsnr4all_af(4,ui_sumr);
vec_FRS_AF_RESULT(1,caltimes)=vec_rsnr4all(4,ui_frs_bestrid-2*ui_linkno);
%DF
ui_cdf_frssum=ui_cdf_frssum+vec_rsnr4all(5,ui_frs_bestrid-2*ui_linkno);
ui_cdf_arssum=ui_cdf_arssum+vec_sortrsnr4all_df(5,ui_sumr);
vec_FRS_DF_RESULT(1,caltimes)=vec_rsnr4all(5,ui_frs_bestrid-2*ui_linkno);

end

ui_mean_frs_caf=mean(vec_FRS_AF_RESULT);
ui_mean_frs_cdf=mean(vec_FRS_DF_RESULT);
ui_mean_ars_caf=mean(vec_ARS_AF_RESULT);
ui_mean_ars_cdf=mean(vec_ARS_DF_RESULT);
ui_caf_percent=ui_mean_frs_caf/ui_mean_ars_caf;
ui_cdf_percent=ui_mean_frs_cdf/ui_mean_ars_cdf;
disp(sprintf('%d\t%d\n',ui_caf_percent,ui_cdf_percent));
